<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOXCODE | LEGENDARY PROFILE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- CSS SETUP (Giao di·ªán Game) --- */
        :root {
            --primary: #00f3ff;
            --secondary: #bc13fe;
            --bg: #050505;
            --glass: rgba(255, 255, 255, 0.05);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Rajdhani', sans-serif;
            color: white;
            user-select: none; /* C·∫•m b√¥i ƒëen ch·ªØ cho gi·ªëng game */
        }

        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 1s;
        }

        .loader-bar {
            width: 300px;
            height: 4px;
            background: #333;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        .loader-progress {
            width: 0%;
            height: 100%;
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            animation: load 2s ease-in-out forwards;
        }

        @keyframes load { 100% { width: 100%; } }

        /* UI OVERLAY */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
            background: radial-gradient(circle at center, transparent 0%, #000000 150%);
        }

        /* HEADER */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rank-badge {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--glass);
            padding: 10px 20px;
            border: 1px solid rgba(255,255,255,0.1);
            border-left: 3px solid var(--primary);
            backdrop-filter: blur(10px);
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
        }

        .rank-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px var(--primary);
        }

        /* STATS (Ch·ªâ s·ªë) */
        .stats-container {
            position: absolute;
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stat-item {
            text-align: right;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* CARD DESCRIPTION (G√≥c d∆∞·ªõi) */
        .card-info {
            position: absolute;
            bottom: 40px;
            left: 40px;
            max-width: 300px;
        }

        .card-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            line-height: 1;
            margin: 0;
            text-transform: uppercase;
            text-shadow: 2px 2px 0px var(--secondary);
        }

        .card-role {
            color: var(--primary);
            font-size: 1.2rem;
            margin-top: 10px;
            font-weight: bold;
            display: inline-block;
            background: rgba(0, 243, 255, 0.1);
            padding: 5px 10px;
            border: 1px solid var(--primary);
        }

        /* ACTION BUTTON */
        .btn-interact {
            position: absolute;
            bottom: 40px;
            right: 40px;
            pointer-events: auto;
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: bold;
            letter-spacing: 2px;
            cursor: pointer;
            overflow: hidden;
            transition: 0.3s;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        .btn-interact:hover {
            background: var(--primary);
            color: black;
            box-shadow: 0 0 30px var(--primary);
        }

        .btn-interact::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }

        .btn-interact:hover::before {
            left: 100%;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .card-name { font-size: 2rem; }
            .stats-container { display: none; } /* ·∫®n ch·ªâ s·ªë tr√™n mobile cho ƒë·ª° r·ªëi */
            .card-info { bottom: 100px; left: 20px; }
            .btn-interact { width: 90%; right: 5%; bottom: 20px; }
        }
    </style>
</head>
<body>

    <div id="loading">
        <div style="font-family: 'Orbitron'; font-size: 20px; letter-spacing: 5px;">INITIALIZING...</div>
        <div class="loader-bar"><div class="loader-progress"></div></div>
    </div>

    <div class="ui-layer">
        <div class="header">
            <div class="rank-badge">
                <span>üèÜ</span>
                <span class="rank-text">BACH KHOA UNIV</span>
            </div>
            <div class="rank-badge" style="border-left-color: var(--secondary)">
                <span class="rank-text">LV.2026</span>
            </div>
        </div>

        <div class="stats-container">
            <div class="stat-item">
                <div class="stat-label">CODER CLASS</div>
                <div class="stat-value" style="color: var(--primary)">S+</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">PROBLEMS SOLVED</div>
                <div class="stat-value">100+</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">WIN RATE</div>
                <div class="stat-value" style="color: var(--secondary)">99.9%</div>
            </div>
        </div>

        <div class="card-info">
            <h1 class="card-name">ƒê·∫∑ng<br>ƒê·ª©c ƒê·∫°i</h1>
            <div class="card-role">&lt;NOXCODE DEV /&gt;</div>
            <p style="color: #aaa; margin-top: 10px; font-size: 0.9rem;">
                H·ªá th·ªëng nh·∫≠n di·ªán: Sinh vi√™n IT - ƒêam m√™ thu·∫≠t to√°n & Game. 
                Tr·∫°ng th√°i: ƒêang ho·∫°t ƒë·ªông.
            </p>
        </div>

        <button class="btn-interact" onclick="window.location.href='https://github.com'">
            CONNECT SYSTEM [+]
        </button>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- C·∫§U H√åNH H·ªÜ TH·ªêNG ---
        const config = {
            cardWidth: 3.0,
            cardHeight: 4.8, // T·ªâ l·ªá th·∫ª b√†i d·ªçc (Tarot/Pokemon)
            cardThickness: 0.1,
            color1: new THREE.Color(0x00f3ff), // Cyan
            color2: new THREE.Color(0xbc13fe), // Purple
        };

        // --- KH·ªûI T·∫†O SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // S∆∞∆°ng m√π v≈© tr·ª•
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // M√†u phim ƒëi·ªán ·∫£nh
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // --- X·ª¨ L√ù TEXTURES (V·∫º TH·∫∫ B·∫∞NG CODE) ---
        // H√†m t·∫°o texture nhi·ªÖu k·ªπ thu·∫≠t s·ªë (Glitch noise)
        function createNoiseTexture() {
            const size = 512;
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size * size * 4; i ++) {
                data[i] = Math.random() * 255;
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;
            return texture;
        }

        // Texture m·∫∑t tr∆∞·ªõc (Ph·ª©c t·∫°p)
        function createFrontTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 1024; cvs.height = 1600;
            const ctx = cvs.getContext('2d');

            // N·ªÅn ƒëen c√¥ng ngh·ªá
            ctx.fillStyle = "#050505";
            ctx.fillRect(0,0,1024,1600);

            // Khung vi·ªÅn Neon
            ctx.lineWidth = 20;
            ctx.strokeStyle = "#00f3ff";
            ctx.strokeRect(40,40,944,1520);

            // C√°c ƒë∆∞·ªùng k·∫ª chi ti·∫øt (Grid)
            ctx.strokeStyle = "rgba(0, 243, 255, 0.2)";
            ctx.lineWidth = 2;
            for(let i=0; i<1600; i+=80) {
                ctx.beginPath(); ctx.moveTo(40, i); ctx.lineTo(984, i); ctx.stroke();
            }

            // H√¨nh Avatar gi·∫£ l·∫≠p (V√≤ng tr√≤n)
            ctx.beginPath();
            ctx.arc(512, 600, 250, 0, Math.PI * 2);
            ctx.strokeStyle = "#bc13fe";
            ctx.lineWidth = 10;
            ctx.stroke();
            
            // Ch·ªØ ch√¨m
            ctx.font = "bold 150px Arial";
            ctx.fillStyle = "rgba(255,255,255,0.05)";
            ctx.textAlign = "center";
            ctx.save();
            ctx.translate(512, 800);
            ctx.rotate(-Math.PI/4);
            ctx.fillText("NOXCODE", 0, 0);
            ctx.restore();

            return new THREE.CanvasTexture(cvs);
        }

        const frontTex = createFrontTexture();
        const noiseTex = createNoiseTexture();

        // --- CUSTOM SHADER MATERIAL (HOLOGRAPHIC EFFECT) ---
        // ƒê√¢y l√† ph·∫ßn kh√≥ nh·∫•t: Vi·∫øt shader ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng 7 m√†u khi nghi√™ng
        const holographicVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const holographicFragmentShader = `
            uniform float time;
            uniform sampler2D map; // Texture g·ªëc
            uniform sampler2D noiseMap; // Texture nhi·ªÖu
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                
                // Hi·ªáu ·ª©ng Fresnel (Vi·ªÅn s√°ng)
                float fresnel = dot(viewDir, normal);
                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                fresnel = pow(fresnel, 3.0);

                // Hi·ªáu ·ª©ng Hologram (ƒê·ªïi m√†u theo g√≥c nh√¨n)
                vec3 hologramColor = vec3(0.0);
                hologramColor.r = sin(fresnel * 10.0 + time) * 0.5 + 0.5;
                hologramColor.g = sin(fresnel * 10.0 + time + 2.0) * 0.5 + 0.5;
                hologramColor.b = sin(fresnel * 10.0 + time + 4.0) * 0.5 + 0.5;

                // L·∫•y m√†u g·ªëc t·ª´ texture v·∫Ω tay
                vec4 baseColor = texture2D(map, vUv);

                // Tr·ªôn m√†u: M√†u g·ªëc + Hologram + Vi·ªÅn s√°ng
                vec3 finalColor = baseColor.rgb + (hologramColor * 0.3 * fresnel) + (vec3(0.0, 0.9, 1.0) * fresnel * 0.8);

                // Th√™m ƒë∆∞·ªùng qu√©t ngang (Scanlines)
                float scanline = sin(vUv.y * 200.0 + time * 5.0) * 0.1;
                finalColor += scanline;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        const holoMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                map: { value: frontTex },
                noiseMap: { value: noiseTex }
            },
            vertexShader: holographicVertexShader,
            fragmentShader: holographicFragmentShader,
        });

        const darkMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x111111,
            metalness: 0.9,
            roughness: 0.2,
            clearcoat: 1.0
        });

        // --- T·∫†O TH·∫∫ ---
        const geometry = new THREE.BoxGeometry(config.cardWidth, config.cardHeight, config.cardThickness);
        // Map v·∫≠t li·ªáu: 4 m·∫∑t c·∫°nh (t·ªëi), M·∫∑t tr∆∞·ªõc (Holo), M·∫∑t sau (T·ªëi)
        const materials = [
            darkMaterial, darkMaterial, darkMaterial, darkMaterial,
            holoMaterial, 
            darkMaterial
        ];
        
        const card = new THREE.Mesh(geometry, materials);
        scene.add(card);

        // Khung vi·ªÅn kim lo·∫°i cho th·∫ª (T·∫°o ƒë·ªô d√†y gi·∫£)
        const frameGeo = new THREE.BoxGeometry(config.cardWidth + 0.2, config.cardHeight + 0.2, config.cardThickness - 0.02);
        const frameMat = new THREE.MeshStandardMaterial({ 
            color: 0x333333, 
            metalness: 1.0, 
            roughness: 0.1,
            emissive: 0x00f3ff,
            emissiveIntensity: 0.2 
        });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        // C·∫Øt r·ªóng gi·ªØa khung (th·ª±c ra l√† ƒë·∫∑t n√≥ l√πi ra sau m·ªôt t√≠ ƒë·ªÉ t·∫°o vi·ªÅn)
        frame.position.z = -0.01;
        card.add(frame); // G·∫Øn khung v√†o th·∫ª

        // --- PARTICLE SYSTEM (Sao bay n·ªÅn) ---
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 2000;
        const posArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i++) {
            // R·∫£i sao ng·∫´u nhi√™n trong kh√¥ng gian r·ªông
            posArray[i] = (Math.random() - 0.5) * 30; 
        }

        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.05,
            color: 0x00f3ff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const particlesMesh = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particlesMesh);

        // --- √ÅNH S√ÅNG ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        // ƒê√®n m√†u xoay quanh th·∫ª
        const light1 = new THREE.PointLight(0x00f3ff, 5, 20);
        scene.add(light1);
        const light2 = new THREE.PointLight(0xbc13fe, 5, 20);
        scene.add(light2);


        // --- LOGIC ANIMATION & INTERACTION ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
        });

        // X√≥a loading khi load xong
        window.onload = () => {
            setTimeout(() => {
                const loader = document.getElementById('loading');
                loader.style.opacity = '0';
                setTimeout(() => loader.remove(), 1000);
            }, 1500); // Gi·∫£ v·ªù load 1.5s
        };

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // 1. C·∫≠p nh·∫≠t Shader (Hologram chuy·ªÉn ƒë·ªông)
            holoMaterial.uniforms.time.value = elapsedTime;

            // 2. Xoay th·∫ª theo chu·ªôt (C√≥ ƒë·ªô tr·ªÖ qu√°n t√≠nh - Smooth)
            targetX = mouseX * 0.001;
            targetY = mouseY * 0.001;

            card.rotation.y += 0.05 * (targetX - card.rotation.y);
            card.rotation.x += 0.05 * (targetY - card.rotation.x);

            // 3. Hi·ªáu ·ª©ng "Th·ªü" (Th·∫ª bay l√™n xu·ªëng nh·∫π)
            card.position.y = Math.sin(elapsedTime) * 0.1;

            // 4. Di chuy·ªÉn ƒë√®n ƒë·ªÉ t·∫°o b√≥ng
            light1.position.x = Math.sin(elapsedTime * 0.7) * 5;
            light1.position.y = Math.cos(elapsedTime * 0.5) * 5;
            light1.position.z = Math.sin(elapsedTime * 0.3) * 5 + 2;

            light2.position.x = Math.cos(elapsedTime * 0.3) * 5;
            light2.position.y = Math.sin(elapsedTime * 0.5) * 5;
            light2.position.z = Math.cos(elapsedTime * 0.7) * 5 + 2;

            // 5. Xoay nh·∫π ƒë√°m sao n·ªÅn
            particlesMesh.rotation.y = elapsedTime * 0.05;

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
